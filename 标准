#标准I/O遇上系统调用I/O


## FILE 遇上 file discripition
先看看 FILE 结构体的定义
在Unix中，使用fileno(FILE* fp),通过流 获取到文件描述符（这实现简单）





## 缓冲区  ，I/O效率
+ 当时在看C primer 是，对标准I/O的缓冲机制时，没有太多的理解，现在回头过来看看，比较简单清晰

    - stdin ,stdout  连接到终端时（或者表达为交互时），都是行缓冲，但，当出现重定向  时，它们是全文缓冲
  - stderr 是全文缓冲
   -普通文件一般是全文缓冲

+ 标准I/O的实现，基于系统I/O----read(),write()
为了减少系统I/O的调用次数，标准I/O引入缓冲区这一特征
那么如何理解行缓冲，全文缓冲，和无缓冲？
我以printf() 为例来说明：
当它被设定为行缓冲的时候：函数接受用户将待写道屏幕上的字符串，在函数中，扫描字符串中的 **‘\n’**,扫描到，将字符串传入write（）函数（fd = STDOUT_FILENO）,字符串被打印到屏幕;
要是该字符串没有出现换行符，那么，触发write（）的条件是行缓冲区被填满

标准输入一个道理，不再累述，标准输入，涉及回显的问题
+ 设置流的缓冲，修改FILE结构体的标志位就行
+ 缓冲区的大小也是修改FILE结构体的成员
+ 对缓冲区的大小设置，对I/O效率蛮大的  

 
  

## 流 stream 的理解

+ stdin ,stdout ,srderr  
+ STDIN_FILENO ,STDOUT_FILENO,STDERR_FILENO

