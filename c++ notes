## 私有继承的意义在?
##引入继承的目的在那？
## struct ,class 两个保留字都可以定义 类
唯一的不同在于 定义的类 具有不同的默认 访问级别

 +  class 继承父类 默认是private
 +  struct 默认的是 public

## 基类 派生类 的 相互转换
+ 派生类 可以转换为基类
+ 基类转换为 派生类 借助 强制转换 或者 dynamic_cast


## constructor
+ 如果类的设计者有去定义哪怕一个自己的类，编译器都不会去为这个类定义默认构造函数
+ 编译器定义的**合成默认构造函数**的成员初始化的规则：
    - 类类型的成员各自执行自己的默认构造函数（没有传入参数，所以，如果没有显式定义了他们自己的构造函数，那么初始化就会报错，最好把他们自己的默认构造函数加上！）
     - 内置或者复合类型的变量，只对定义在全局作用域的类进行初始化，局部作用域的不进行初始化

+ ** 初始化成员列表 **　
 　１.*必要性* : 引用，const 常量 的初始化必须借助初始化成员列表

       2.* 初始化次序 *：如果有存在使用前一个成员变量初始化后一个成员变量，注意成员变量在类中的声明顺序

+ ** 默认构造函数 **:尽量为类去定义默认构造函数

+ ** 默认实参 与构造函数**　
　是对前两种的构造函数的综合，减少了代码的重复
　ｅｇ：

```
　Sale_item(const std::string &book = " "):isbn(book),units_sold(0),revenue(0.0){}
```   

 等价于：

```
　Sale_item(const std::string &book):isbn(book),units_sold(0),revenue(0.0) {}
     Sale_item():unit_sold(0),revenue(0.0) {}
```
##  析构函数

+ 何时编写自己的析构函数 
 ** rule of three **
>一个类需要析构函数，则他需要赋值操作符和复制构造函数（经验法则）

+   合成析构函数 （默认析构函数）
编译器总是会为我们生成，区别于默认析构函数 
    - 执行规则： 先执行用户自定义的析构函数 ，然后执行合成析构函数
    - 合成析构函数 按定义的内置数据类型或者复合数据类型创建的逆序来撤销对象，对于类类型，调用该成员的析构函数来撤销对象

+  


## const  成员函数

> 该函数不能修改成员变量，不能调用非const成员函数

尽量加上该关键字，增强程序的健壮性




## 动态绑定
+ 触发条件　只能通过基类的引用或者指针调用虚成员，也就是说：1.虚函数 ;2 引用或指针;
+ 虚函数的参数类型／返回值的类型必须一致，但，有一种情况例外
　如果虚函数的返回值是　当前类的引用或指针类型，　那么，派生的的虚函数的重载时，可以返回　派生类的类型的引用或指针　
 　如果不是虚函数：传入啥参数类型的类，调用它本身的成员函数，传入其他
+ ** 句柄类（handle）　**
> 引入句柄类的目的是屏蔽类的继承层次　


 
    　

##成员变量有指针或引用

+ ** 类之间共享指针所指对象－－－－ 智能指针 **
+ **指针所指的对象是各个对象独有－－－－采取取值型行为**



+ ** handle 类（包装类）**






## 虚函数

+ 纯虚函数














    







