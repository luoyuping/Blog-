# 对tcp/ip 的一些疑问&理解&总结

> tcp/ip  协议栈负责数据的封装，发送，接收，解封装，分发到应用程序
>tcp/ip 协议栈是参照网络五层模型，根据RFC×××网络规范，实现的系统程序，提供网络服务

## socket 的理解

## 端口的理解
**为啥引入端口**
>在网络通信过程中，需要唯一识别通信两端的端点，就是使用端口识别运行于某主机中的应用程序。如果没有引入端口，则只能通过 进程号进行识别。进程号是系统动态分配的，不同的系统会使用不同的进程标识符，应用程序在运行之前不知道自己的进程号，如果需要运行后再广播进程号则很难 保证通信的顺利进行。而引入端口后，就可以利用端口号识别应用程序，同时通过固定端口号来识别和使用公共服务，如HTTP和FTP等。

**  一个端口对应一个网络应用，一个应用可占据多个端口 **
我原来有这样的疑惑：
>编写网络程序，首先，调用*bind(sockfd,server_addr,length)* 将某个socket 绑定到某个端口;
 然后，你调用*accept(sockfd,sock_addr_client,length)*,得到一个新的链接socket;
那么，在调用bind时，是否意味着sockfd 已经在不断接测是否有新的链接请求，那么它不就一直在占用这端口了吗，数据的接收和发送的套接字是通过哪个端口进行工作的？是否工作在另一个端口？

[看这篇blog](http://blog.csdn.net/fansongy/article/details/7767129) 

>我谈谈个人的理解：
 bind（）调用后的套接字的结构体，填充着服务端的ip和port;
accept调用后，获取到客户端的ip和端口;
tcp/ip 通讯在**传输层**，**网络层**的传输的**源**和**目地**全部获取到
**socket 是对TCP/IP协议栈的抽象，不是简单对网络层次的映射**

##socket本无C/S模型
tcp/ip  没有去规定设计者去这样设计网络框架，这是广大程序员设计的经典模型;
常见C/S，P2P（时常会有一个资源发现点）

##原始套接字 & 高级套接字 & 标准套接字
+ tcp 套接字，udp套接字为标准套接字，与传输层打交道; 
+ 原始套接字，与IP网络协议栈打交道，利用原始套接字构建特定类型的TCP或者UDP的分组
+ 
| 原始套接字|标准套接字|高级套接字|
|：-------------|：-------------------：|---------------------：|
|socket(AF_INET,SOCK_RAW,proctal)|socket(AF_INET,SOCK_STREAM  'or' SOCK_DGRM,0)|socket(AF_UNIX,SOCK_STREAM  'or' SOCK_DGRM,0)










